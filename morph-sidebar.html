<link rel="import" href="/bower_components/polymer/lib/utils/render-status.html">
<link rel="import" href="/bower_components/polymer/lib/mixins/gesture-event-listeners.html"> <!-- import needed to use Polymer Gestures Mixin -->
<link rel="import" href="/bower_components/morph-element/morph-element.html">

<dom-module id="morph-sidebar">
  <template>
    <style>
      :host {
        --sidebar-width: 260px;
        --sidebar-background-color: #e7e7e7;

        background: var(--sidebar-background-color);
        box-sizing: border-box;
        display: block;
        height: 100%;
        overflow: auto;
        position: absolute;
        top: 0;
        transform: translate3d(0,0,0);
        width: var(--sidebar-width);
        z-index: 1000;
        -webkit-overflow-scrolling: touch;
      }

      :host([platform="ios"]) {
        transition-duration: 400ms;
      }

      :host([platform="android"]) {
        transition: 300ms;
      }

      :host([platform="android"][open]) {
        box-shadow: 0 0 20px rgba(0,0,0,.5);
      }

      :host(.not-animated) {
        transition: 0ms;
      }

      :host([side="left"]) {
        left: 0;
      }

      :host([side="right"]) {
        right: 0;
      }

      :host([side="left"]:not([open])) {
        transform: translate3d(-100%, 0, 0);
      }

      :host([side="right"]:not([open])) {
        transform: translate3d(100%, 0, 0);
      }
    </style>

    <div id="contentContainer">
      <slot></slot>
    </div>


  </template>

  <script>
    /**
     * `morph-sidebar`
     * Sidebar that morphs for current mobile OS
     *
     * @customElement
     * @polymer
     * @demo morph-sidebar/demo/index.html
     */
    class MorphSidebar extends Polymer.GestureEventListeners(MorphElement) {
      static get is() { return 'morph-sidebar'; }

      static get properties() {
        return {
          side: {
            type: String,
            value: "left",
            reflectToAttribute: true
          },
          open: {
            type: Boolean,
            value: false,
            notify: true,
            reflectToAttribute: true
          },
          position: {
            type: String,
            readOnly: true,
            reflectToAttribute: true
          }
        };
      }

      /**
       * Set open property to true use to open the sidebar
       */
      setOpen() {
        this.set('open', true);
      }

      /**
       * Set open property to false use to close the sidebar
       */
      setClosed() {
        this.set('open', false);
      }

      /**
       * Toggle open property open to close and close to open
       */
      toggle() {
        this.open = !this.open;
      }

      /**
       * Gets the width of the sidebar.
       *
       * @return {number} The width of the sidebar in pixels.
       */
      getWidth() {
        return this._savedWidth || this.$.contentContainer.offsetWidth;
      }

      _track(event) {
        switch (event.detail.state) {
          case 'start':
            console.log('start track');
            this._trackStart(event);
            break;
          case 'track':
            console.log('tracking...');
            this._trackMove(event);
            break;
          case 'end':
          console.log('end track');
            this._trackEnd(event);
            break;
        }
      }

      _trackStart(event) {
        var rect = this.$.contentContainer.getBoundingClientRect();
        this._savedWidth = rect.width;
        if (this.position === 'left') {
          this._translateOffset = rect.left;
        } else {
          this._translateOffset = rect.right - window.innerWidth;
        }
        this._trackDetails = [];
        // Disable transitions since style attributes will reflect user track events.
        // this._styleTransitionDuration(0);
        this.style.visibility = 'visible';
      }

      _trackMove(event) {
        this._translateDrawer(event.detail.dx + this._translateOffset);
      }

      _trackEnd(event) {
        var x = event.detail.dx + this._translateOffset;
        var drawerWidth = this.getWidth();
        var isPositionLeft = this.position === 'left';
        var isInEndState = isPositionLeft ? (x >= 0 || x <= -drawerWidth) :
          (x <= 0 || x >= drawerWidth);
        if (!isInEndState) {
          // No longer need the track events after this method returns - allow them to be GC'd.
          var trackDetails = this._trackDetails;
          this._trackDetails = null;
          
        }
        // If the drawer is not flinging, toggle the opened state based on the position of
        // the drawer.
        var halfWidth = drawerWidth / 2;
        if (event.detail.dx < -halfWidth) {
          this.opened = this.position === 'right';
        } else if (event.detail.dx > halfWidth) {
          this.opened = this.position === 'left';
        }
        
        console.log('getWidth', this.getWidth()); 

        this._styleTransitionDuration(this.transitionDuration);
        this._resetDrawerTranslate();
        this.style.visibility = '';
      }

      _translateDrawer(x) {
        var drawerWidth = this.getWidth();
        if (this.position === 'left') {
          x = Math.max(-drawerWidth, Math.min(x, 0));
          // this.$.scrim.style.opacity = 1 + x / drawerWidth;
        } else {
          x = Math.max(0, Math.min(x, drawerWidth));
          // this.$.scrim.style.opacity = 1 - x / drawerWidth;
        }
        this.translate3d(x + 'px', '0', '0', this.$.contentContainer);
      }





      ready() {
        super.ready();

        let startPoint, endPoint, diff, travel;

        Polymer.Gestures.addListener(this, 'track', '_track');
        
        // add gesture event listener to track touch swipe
        Polymer.Gestures.addListener(this, 'track', e => {
          // detects tracking at the start of each tracking event
          if(e.detail.state == 'start') {
            // gets the x coordinate of start of track event
            startPoint = e.detail.x;
          }

          

          // detects end of tracking events
          if(e.detail.state == 'end') {
            // gets the x coordinate of end of track event
            endPoint = e.detail.x;
            diff = startPoint - endPoint; // gets the difference between the start and end x coordinate
            travel = Math.abs(diff); // gets the absolute value of the difference (positive values only)
            if(travel > 10) {
              // set open to false when travel is greater than 10
              this.setClosed(); 
            }
          }

        });
      }

      connectedCallback() {
        super.connectedCallback();
        console.log('my-element created!');
        Polymer.RenderStatus.afterNextRender(this, function() {
          Polymer.Gestures.addListener(this, 'track', this._track);
          // this.setScrollDirection('y');
        });
      }


    }

    window.customElements.define(MorphSidebar.is, MorphSidebar);
  </script>
</dom-module>
